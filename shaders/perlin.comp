#version 430

layout (binding = 0, rgba32f) uniform image2D outputImage;

layout (local_size_x = 16, local_size_y = 16) in;

uniform int seed = 0;
uniform float scale = 5.0;

// https://en.wikipedia.org/wiki/Perlin_noise#Permutation
int perm[256] = int[256](
    151, 160, 137,  91,  90,  15, 131,  13, 201,  95,  96,  53, 194, 233,   7, 225,
    140,  36, 103,  30,  69, 142,   8,  99,  37, 240,  21,  10,  23, 190,   6, 148,
    247, 120, 234,  75,   0,  26, 197,  62,  94, 252, 219, 203, 117,  35,  11,  32,
    57,  177,  33,  88, 237, 149,  56,  87, 174,  20, 125, 136, 171, 168,  68, 175,
    74,  165,  71, 134, 139,  48,  27, 166,  77, 146, 158, 231,  83, 111, 229, 122,
    60,  211, 133, 230, 220, 105,  92,  41,  55,  46, 245,  40, 244, 102, 143,  54,
    65,   25,  63, 161,   1, 216,  80,  73, 209,  76, 132, 187, 208,  89,  18, 169,
    200, 196, 135, 130, 116, 188, 159,  86, 164, 100, 109, 198, 173, 186,   3,  64,
    52,  217, 226, 250, 124, 123,   5, 202,  38, 147, 118, 126, 255,  82,  85, 212,
    207, 206,  59, 227,  47,  16,  58,  17, 182, 189,  28,  42, 223, 183, 170, 213,
    119, 248, 152,   2,  44, 154, 163,  70, 221, 153, 101, 155, 167,  43, 172,   9,
    129,  22,  39, 253,  19,  98, 108, 110,  79, 113, 224, 232, 178, 185, 112, 104,
    218, 246,  97, 228, 251,  34, 242, 193, 238, 210, 144,  12, 191, 179, 162, 241,
    81,   51, 145, 235, 249,  14, 239, 107,  49, 192, 214,  31, 181, 199, 106, 157,
    184,  84, 204, 176, 115, 121,  50,  45, 127,   4, 150, 254, 138, 236, 205,  93,
    222, 114,  67,  29,  24,  72, 243, 141, 128, 195,  78,  66, 215,  61, 156, 180
);

int hash(int x) {
    return perm[x & 255];
}

void ShuffleArray(int seed) {
    for (int i = 255; i > 0; i--) {
        int j = (seed + i) % (i + 1);
        int temp = perm[i];
        perm[i] = perm[j];
        perm[j] = temp;
    }
}

// Implentation for fade, gradient, and noise, just converted to glsl: https://github.com/Reputeless/PerlinNoise/blob/master/PerlinNoise.hpp
float fade(float t) {
    return t * t * t * (t * (t * 6 - 15) + 10);
}


float Grad(int hash, float x, float y, float z) {
    int h = hash & 15;
    float u = h < 8 ? x : y;
    float v = h < 4 ? y : (h == 12 || h == 14 ? x : z);

    return ((h & 1) == 0 ? u : -u) + ((h & 2) == 0 ? v : -v);
}

float Noise_3D(vec3 pos) {
    vec3 i = floor(pos);
    vec3 f = pos - i;

    float u = fade(f.x);
    float v = fade(f.y);
    float w = fade(f.z);

    int ix = int(i.x) & 255;
    int iy = int(i.y) & 255;
    int iz = int(i.z) & 255;

    int A = (perm[ix] + iy) & 255;
    int B = (perm[(ix + 1) & 255] + iy) & 255;

    int AA = (perm[A] + iz) & 255;
    int AB = (perm[(A + 1) & 255] + iz) & 255;

    int BA = (perm[B] + iz) & 255;
    int BB = (perm[(B + 1) & 255] + iz) & 255;

    float p0 = Grad(perm[AA], f.x, f.y, f.z);
    float p1 = Grad(perm[BA], f.x - 1, f.y, f.z);
    float p2 = Grad(perm[AB], f.x, f.y - 1, f.z);
    float p3 = Grad(perm[BB], f.x - 1, f.y - 1, f.z);
    float p4 = Grad(perm[(AA + 1) & 255], f.x, f.y, f.z - 1);
    float p5 = Grad(perm[(BA + 1) & 255], f.x - 1, f.y, f.z - 1);
    float p6 = Grad(perm[(AB + 1) & 255], f.x, f.y - 1, f.z - 1);
    float p7 = Grad(perm[(BB + 1) & 255], f.x - 1, f.y - 1, f.z - 1);

    float q0 = mix(p0, p1, u);
    float q1 = mix(p2, p3, u);
    float q2 = mix(p4, p5, u);
    float q3 = mix(p6, p7, u);

    float r0 = mix(q0, q1, v);
    float r1 = mix(q2, q3, v);

    return mix(r0, r1, w) * 0.5 + 0.5; // Normalize to [0, 1]
}

void main() {
    ShuffleArray(seed);

    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    float width = 2048.0;
    float height = 1024.0;

    vec2 uv = vec2(float(coord.x) / width, float(coord.y) / height);

    // UV to spherical coords
    float theta = uv.x * 2.0 * 3.14159265359;
    float phi = uv.y * 3.14159265359;

    // Calculate normal
    vec3 normal;
    normal.x = sin(phi) * cos(theta);
    normal.y = sin(phi) * sin(theta);
    normal.z = cos(phi);

    // Sample 3d noise with normal of sphere
    float noiseValue = Noise_3D(normal * scale);

    // Write to image, x = longitude, y = latitude
    vec4 noiseColor = vec4(vec3(noiseValue), 1.0);
    imageStore(outputImage, coord, noiseColor);
}